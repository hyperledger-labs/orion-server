"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9494],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},k=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=s(n),k=o,u=h["".concat(c,".").concat(k)]||h[k]||d[k]||i;return n?r.createElement(u,a(a({ref:t},p),{},{components:n})):r.createElement(u,a({ref:t},p))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=k;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[h]="string"==typeof e?e:o,a[1]=l;for(var s=2;s<i;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}k.displayName="MDXCreateElement"},8234:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const i={id:"block-skip-chain",title:"Block Skip Chain"},a=void 0,l={unversionedId:"architecture-and-design/block-skip-chain",id:"architecture-and-design/block-skip-chain",isDocsHomePage:!1,title:"Block Skip Chain",description:"Proofs algorithm based on skiplist like chain",source:"@site/docs/architecture-and-design/block-skip-chain.md",sourceDirName:"architecture-and-design",slug:"/architecture-and-design/block-skip-chain",permalink:"/orion-server/docs/architecture-and-design/block-skip-chain",tags:[],version:"current",frontMatter:{id:"block-skip-chain",title:"Block Skip Chain"},sidebar:"Documentation",previous:{title:"Transaction Merkle Tree",permalink:"/orion-server/docs/architecture-and-design/tx-merkle-tree"},next:{title:"Crypto-Based Authentication",permalink:"/orion-server/docs/security-and-trust-model/authentication"}},c=[{value:"Proofs algorithm based on skiplist like chain",id:"proofs-algorithm-based-on-skiplist-like-chain",children:[{value:"Ledger connectivity proof example",id:"ledger-connectivity-proof-example",children:[],level:3},{value:"Proof generation and validation algorithm",id:"proof-generation-and-validation-algorithm",children:[],level:3}],level:2}],s={toc:c};function p(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,r.Z)({},s,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"proofs-algorithm-based-on-skiplist-like-chain"},"Proofs algorithm based on skiplist like chain"),(0,o.kt)("p",null,"To prove ledger consistency, we need to prove that a block is part of the ledger, using blockchain properties, like the hash of the previous block."),(0,o.kt)("p",null,"The naive implementation is to return all block hashes from the genesis block to the block we want to validate, given users already keep the genesis block locally. The size of the proof is O(N), which is not acceptable for big ledgers."),(0,o.kt)("p",null,"Bitcoin-like ledgers use this approach because ledger blocks are already replicated between clients and stored locally."),(0,o.kt)("p",null,"Here we discuss implementation, which provides proof of O(log(N)) size, computation, and space-efficiency."),(0,o.kt)("p",null,"If the ",(0,o.kt)("img",{src:"https://render.githubusercontent.com/render/math?math=BlockIndex \\mod 2^{i} = 0"})," block header, in addition to the previous block hash, should contain the hash of the ",(0,o.kt)("img",{src:"https://render.githubusercontent.com/render/math?math=BlockIndex - 2^{i}"})," block (see the example below)\n",(0,o.kt)("img",{alt:"Block Skip List",src:n(4258).Z}),(0,o.kt)("br",{parentName:"p"}),"\n","it's worth mentioning, that the block with index ",(0,o.kt)("img",{src:"https://render.githubusercontent.com/render/math?math=2^{i}"})," will contain ",(0,o.kt)("em",{parentName:"p"},"i")," hashes in its header."),(0,o.kt)("h3",{id:"ledger-connectivity-proof-example"},"Ledger connectivity proof example"),(0,o.kt)("p",null,"The validation algorithm finds the shortest path from the last block in the ledger to block ",(0,o.kt)("em",{parentName:"p"},"i")," and from block ",(0,o.kt)("em",{parentName:"p"},"i")," to the genesis block. The result is a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"BlockHeader")," containing each block in the path."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Let's mark blocks in the picture as 0,1,...,7,8"),(0,o.kt)("li",{parentName:"ul"},"To generate a proof for block 3",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"First we build a path from the last block to 3",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Adding the header of the last block, 8"),(0,o.kt)("li",{parentName:"ul"},"8 has 4 hashes, one of them to block 4, so adding 4's header"),(0,o.kt)("li",{parentName:"ul"},"4 has access to 3, so we add 3's header as well, for consistency"))),(0,o.kt)("li",{parentName:"ul"},"Next stage is to find the path to the genesis block",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Block 3 contains only one hash, of block 2, so we add the header of block 2"),(0,o.kt)("li",{parentName:"ul"},"Block 2 contains two hashes, block 1 and block 0, so we add the block 0 hash"))),(0,o.kt)("li",{parentName:"ul"},"As a result, we now have (8, 4, 3, 2, 0)"),(0,o.kt)("li",{parentName:"ul"},"Now let's reverse it, because it's easier to validate hashes for the genesis block"))),(0,o.kt)("li",{parentName:"ul"},"Validation of proof is done by checking hash references in all the blocks in the path")),(0,o.kt)("h3",{id:"proof-generation-and-validation-algorithm"},"Proof generation and validation algorithm"),(0,o.kt)("p",null,"For detailed ledger connectivity proof generation and verification, see ",(0,o.kt)("a",{parentName:"p",href:"../getting-started/proofs-and-verification/proofs#ledger-connectivity-proof"},"here"),"."))}p.isMDXComponent=!0},4258:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/BlockSkipList-2509c9fa18575e03890cc838447e2961.png"}}]);