"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5334],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(a),h=r,m=u["".concat(s,".").concat(h)]||u[h]||c[h]||i;return a?n.createElement(m,o(o({ref:t},p),{},{components:a})):n.createElement(m,o({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},4692:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const i={id:"state-merkle-patricia-tree",title:"State Merkle Patricia Tree"},o=void 0,l={unversionedId:"architecture-and-design/state-merkle-patricia-tree",id:"architecture-and-design/state-merkle-patricia-tree",isDocsHomePage:!1,title:"State Merkle Patricia Tree",description:"Merkle-Patricia Trie",source:"@site/docs/architecture-and-design/state-merkle-patricia-tree.md",sourceDirName:"architecture-and-design",slug:"/architecture-and-design/state-merkle-patricia-tree",permalink:"/orion-server/docs/architecture-and-design/state-merkle-patricia-tree",tags:[],version:"current",frontMatter:{id:"state-merkle-patricia-tree",title:"State Merkle Patricia Tree"},sidebar:"Documentation",previous:{title:"Provenance Data",permalink:"/orion-server/docs/architecture-and-design/provenance-data"},next:{title:"Transaction Merkle Tree",permalink:"/orion-server/docs/architecture-and-design/tx-merkle-tree"}},s=[{value:"Merkle-Patricia Trie",id:"merkle-patricia-trie",children:[{value:"Patricia trie",id:"patricia-trie",children:[{value:"Trie example",id:"trie-example",children:[],level:4}],level:3},{value:"Trie update algorithm",id:"trie-update-algorithm",children:[],level:3},{value:"Trie update example",id:"trie-update-example",children:[],level:3},{value:"Trie value delete",id:"trie-value-delete",children:[],level:3},{value:"Trie proofs",id:"trie-proofs",children:[],level:3},{value:"BCDB implementation details",id:"bcdb-implementation-details",children:[],level:3}],level:2}],d={toc:s};function p(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"merkle-patricia-trie"},"Merkle-Patricia Trie"),(0,r.kt)("p",null,"The Merkle-Patricia trie is a combination of two tree data structures:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Merkle tree \u2013 a tree that uses child hashes instead of pointers"),(0,r.kt)("li",{parentName:"ul"},"Patricia trie \u2013 an optimized dictionary tree")),(0,r.kt)("h3",{id:"patricia-trie"},"Patricia trie"),(0,r.kt)("p",null,"The main difference between a Patricia trie and a regular dictionary tree is the algorithm used to compress long one-child branches into a single node.\n",(0,r.kt)("img",{alt:"Trie ethereum style",src:a(6995).Z})),(0,r.kt)("p",null,"Different implementations contain between two and three types of different nodes, but there are two important types:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Branch node \u2013 this node has more than one child and contains the list children","[ALPHABET_SIZE]"," of children pointers."),(0,r.kt)("li",{parentName:"ul"},"Extension node \u2013 this non-leaf node represents a sequence of nodes that has only one child and contains a key that represents all these nodes as one.")),(0,r.kt)("p",null,"An ",(0,r.kt)("em",{parentName:"p"},"Optional third type")," of node is the Value node. This leaf node is similar to the Extension node, but instead of a pointer to the next node, it contains value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"* Some implementations combine Extension and Value nodes into single node type.\n")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Trie Node Types",src:a(6342).Z})),(0,r.kt)("h4",{id:"trie-example"},"Trie example"),(0,r.kt)("p",null,"The following figure shows a sample trie with all possible types of inter-trie connections and contains the following data:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"5        -> A"),(0,r.kt)("li",{parentName:"ul"},"A123     -> B"),(0,r.kt)("li",{parentName:"ul"},"FAB23    -> C"),(0,r.kt)("li",{parentName:"ul"},"DA1F     -> D"),(0,r.kt)("li",{parentName:"ul"},"DA1F4    -> E"),(0,r.kt)("li",{parentName:"ul"},"DA1F111  -> F"),(0,r.kt)("li",{parentName:"ul"},"50FF1    -> G"),(0,r.kt)("li",{parentName:"ul"},"50FFC561 -> H"),(0,r.kt)("li",{parentName:"ul"},"DA1F48A  -> I")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Sample Trie",src:a(8174).Z})),(0,r.kt)("h3",{id:"trie-update-algorithm"},"Trie update algorithm"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If a node with an updated key exists, just update Value and all hash pointers up to the root."),(0,r.kt)("li",{parentName:"ul"},"If such a node doesn't exist, traverse trie for all key matching nodes.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If the last matching node is Value node:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Convert it to an ExtensionNode followed by BranchNode and add a new ValueNode with the remaining path, without the first character."))),(0,r.kt)("li",{parentName:"ul"},"If the last matching node is Branch node, find the next node, pointed to by ",(0,r.kt)("em",{parentName:"li"},"node.Children","[nibble]"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"When the next node is an NIL, replace it with a new ValueNode with the remaining path."),(0,r.kt)("li",{parentName:"ul"},"When the next node is a ValueNode, add an ExtensionNode with matching path, followed by a BranchNode, and make the new BranchNode point to the original ValueNode with the rest of its path and a new ValueNode."),(0,r.kt)("li",{parentName:"ul"},"When the next node is an ExtensionNode, add another ExtensionNode with common path and create a new BranchNode that points to the original ExtensionNode and a new ValueNode."))),(0,r.kt)("li",{parentName:"ul"},"Update all hashes up to the root.")))),(0,r.kt)("h3",{id:"trie-update-example"},"Trie update example"),(0,r.kt)("p",null,"This example illustrates how one update can affect multiple nodes in trie, not mention hashes in the whole branch."),(0,r.kt)("p",null,"We start from a trie that contains only three Value nodes, with three values:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A123 -> B"),(0,r.kt)("li",{parentName:"ul"},"DA1F -> D"),(0,r.kt)("li",{parentName:"ul"},"50FF1A -> G")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Original Trie",src:a(6316).Z})),(0,r.kt)("p",null,"After the insert of (DA1FE111 -> F), we see three new nodes - one Extension node, one Branch node that replaced the Value node holding value (D), and one Value node that holds the new value (F)."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Updated Trie",src:a(4436).Z})),(0,r.kt)("h3",{id:"trie-value-delete"},"Trie value delete"),(0,r.kt)("p",null,"We just mark the node that contains the deleted value with the tombstone bit - ",(0,r.kt)("inlineCode",{parentName:"p"},"isDeleted")," flag. Thus value delete is the same as the value update, while ",(0,r.kt)("inlineCode",{parentName:"p"},"isDeleted")," changes instead of value. Because this flag affects the node hash, it is tamper resistant."),(0,r.kt)("h3",{id:"trie-proofs"},"Trie proofs"),(0,r.kt)("p",null,"First, lets define the path from the trie root to the value. It's an ordered list of nodes from the root node to the Value node or the Branch node that actually contains value."),(0,r.kt)("p",null,"Each node in the path is represented as a list of byte arrays. Each byte array can be a hash of child node(s) (branch node, extension node) or a part of a key (extension node, value node). In addition, in our implementation, no actual value is stored in the node, but only the hash of the ",(0,r.kt)("inlineCode",{parentName:"p"},"<key, value>")," pair. The ",(0,r.kt)("inlineCode",{parentName:"p"},"isDeleted")," tombstone bit is represented as a separate byte array as well."),(0,r.kt)("p",null,"Proof generation:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Arguments are block number and key (in our case db+key).",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"As an optional argument, ",(0,r.kt)("inlineCode",{parentName:"li"},"isDeleted")," can be passed too."))),(0,r.kt)("li",{parentName:"ul"},"The server loads a snapshot of MPTrie at the time of block ",(0,r.kt)("inlineCode",{parentName:"li"},"N")," ",(0,r.kt)("img",{alt:"Trie Block snapshot",src:a(1121).Z})),(0,r.kt)("li",{parentName:"ul"},"The server looks for a path that contains ",(0,r.kt)("inlineCode",{parentName:"li"},"key"),".",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If a path exists, it's returned to the user in the form of a list of byte arrays.")))),(0,r.kt)("p",null,"Proof validation:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Hash of ",(0,r.kt)("inlineCode",{parentName:"li"},"<key, value>")," pair calculated and marked as ",(0,r.kt)("inlineCode",{parentName:"li"},"current hash")),(0,r.kt)("li",{parentName:"ul"},"Validation starts from leaf node."),(0,r.kt)("li",{parentName:"ul"},"For each node in a path, check if any of the byte array in the list represents a node equal to ",(0,r.kt)("inlineCode",{parentName:"li"},"current hash"),".",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If no such byte array exists, the validation terminates with a failure."),(0,r.kt)("li",{parentName:"ul"},"Calculate node hash by concatenating all byte arrays in the list and hashing result."),(0,r.kt)("li",{parentName:"ul"},"Make node hash new ",(0,r.kt)("inlineCode",{parentName:"li"},"current hash"),"."))),(0,r.kt)("li",{parentName:"ul"},"For last node in path, check that its hash equals the trie root hash stored in block header.")),(0,r.kt)("h3",{id:"bcdb-implementation-details"},"BCDB implementation details"),(0,r.kt)("p",null,"The server keeps dynamically updating the state trie. Its root is stored as part of the block header. Once the block is committed to the block store, all block transactions applied to trie and all changes (deltas) to trie are stored in the associated trie store."),(0,r.kt)("p",null,"The server-side implementation is composed of two parts - one is the MPTrie structure and the other is the trie store."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"MPTrie")," implements all trie logic, like adding/updating/deleting values."),(0,r.kt)("p",null,"Trie ",(0,r.kt)("inlineCode",{parentName:"p"},"Store")," stores all nodes in underlying storage. ",(0,r.kt)("inlineCode",{parentName:"p"},"nodePtr")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"valuePrt")," are basically node hash and ",(0,r.kt)("inlineCode",{parentName:"p"},"<db, key, value>")," tuple hash."),(0,r.kt)("p",null,"Both structures operate ",(0,r.kt)("inlineCode",{parentName:"p"},"TrieNode"),". Each type of node exposes its ",(0,r.kt)("inlineCode",{parentName:"p"},"Hash")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"[][]byte")," array of all inside hashes used to calculate node hash."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type TrieNode interface {\n    hash() ([]byte, error)\n    bytes() [][]byte\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Trie")," API:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// NewTrie creates new Merkle-Patricia Trie, with backend store.\n// If root node Hash is not nil, root node loaded from store, otherwise, empty trie is created\nfunc NewTrie(rootHash []byte, store Store) (*MPTrie, error)\n// Calculates trie hash, actually, it is root node hash\nfunc (t *MPTrie) Hash() ([]byte, error)\n// Get returns value associated with key\nfunc (t *MPTrie) Get(key []byte) ([]byte, error)\n// Update key value\nfunc (t *MPTrie) Update(key, value []byte) error\n// Delete key\nfunc (t *MPTrie) Delete(key []byte) ([]byte, error)\n// GetProof calculates proof (path) from node contains value to root node in trie\n// for given key and delete flag, i.e. if value was deleted, but delete flag id false,\n// no proof will be calculated\nfunc (t *MPTrie) GetProof(key []byte, isDeleted bool) (*state.Proof, error)\n\ntype Proof struct {\n    // For each node in trie path, it contains bytes of all node fields and []byte{1} in case of deleted flag true\n    // Path is from rom node contains value to root node\n    // Exactly same byte slices used to calculate node hash.\n    Path []*types.MPTrieProofElement\n}\n\nfunc (p *Proof) Verify(leafHash, rootHash []byte, isDeleted bool) (bool, error)\n")),(0,r.kt)("p",null,"Trie ",(0,r.kt)("inlineCode",{parentName:"p"},"Store")," API:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"\n// Trie store \ntype Store interface {\n    // GetNode returns TrieNode associated with key/ptr. It may be temporal node\n    // created by PutNode, node market to persist after PersistNode or after executing\n    // CommitPersistChanges actually stored in backend storage node\n    GetNode(nodePtr []byte) (TrieNode, error)\n    // GetValue return value bytes associated with value ptr. Same logic as in GetNode applies.\n    GetValue(valuePtr []byte) ([]byte, error)\n    // PutNode store node data it temporal way - it my be accessed by GetNode, but will not stored in backend store.\n    PutNode(nodePtr []byte, node TrieNode) error\n    // PutValue do the same as PutNode, but for value\n    PutValue(valuePtr, value []byte) error\n    // PersistNode mark temporal node to be persisted to backend storage in next call to CommitPersistChanges\n    PersistNode(nodePtr []byte) (bool, error)\n    // PersistValue do same as PersistNode, but for value\n    PersistValue(valuePtr []byte) (bool, error)\n    // Height returns number of last block trie was persist for\n    Height() (uint64, error)\n    // CommitChanges frees all inMemory nodes and actually stores nodes and value marked to be persist by\n    // PersistNode and PersistValue in single backend store update - usually used with block number\n    CommitChanges(blockNum uint64) error\n    // RollbackChanges free all in memory nodes and nodes marked to be persist, without storing anything in\n    // underlying database. Operation can cause to current MPTrie become invalid, so always reload trie\n    // after the call\n    RollbackChanges() error\n}\n")))}p.isMDXComponent=!0},6342:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/MPT-Node-Types-796cc111cf4bb35b223aec4889b76011.png"},8174:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/MPT-Sample-Trie-1a35c99088c4c299f7d923c6e2feba56.png"},6316:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/MPT-Update-1-3f0fa9f59c1ed41e6f63c37481db3b2b.png"},4436:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/MPT-Update-2-078876a5d51d89c8b4579562687086c2.png"},1121:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/PatriciaMerkleTrie-076c0eed98aa8f8f45b982509e05e5c6.png"},6995:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/worldstatetrie-502af37fecdc7cb7af5544a1a10bc2aa.png"}}]);